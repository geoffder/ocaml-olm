<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Funcs (olm.Olm.C.Funcs)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">olm</a> &#x00BB; <a href="../../index.html">Olm</a> &#x00BB; <a href="../index.html">C</a> &#x00BB; Funcs</nav><h1>Module <code>C.Funcs</code></h1></header><dl><dt class="spec value" id="val-inbound_group_session_size"><a href="#val-inbound_group_session_size" class="anchor"></a><code><span class="keyword">val</span> inbound_group_session_size : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>inbound_group_session_size ()</code></p><p>Get the size of an inbound group session, in bytes.</p></dd></dl><dl><dt class="spec value" id="val-inbound_group_session"><a href="#val-inbound_group_session" class="anchor"></a><code><span class="keyword">val</span> inbound_group_session : <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span></code></dt><dd><p><code>inbound_group_session session key key_length message_index</code></p><p>Initialise an inbound group session object using the supplied memory The supplied memory should be at least olm_inbound_group_session_size() bytes.</p></dd></dl><dl><dt class="spec value" id="val-inbound_group_session_last_error"><a href="#val-inbound_group_session_last_error" class="anchor"></a><code><span class="keyword">val</span> inbound_group_session_last_error : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>char Ctypes_static.ptr</span></code></dt><dd><p><code>inbound_group_session_last_error sess</code></p><p>A null terminated string describing the most recent error to happen to a group session</p></dd></dl><dl><dt class="spec value" id="val-clear_inbound_group_session"><a href="#val-clear_inbound_group_session" class="anchor"></a><code><span class="keyword">val</span> clear_inbound_group_session : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>clear_inbound_group_session sess</code></p><p>Clears the memory used to back this group session</p></dd></dl><dl><dt class="spec value" id="val-pickle_inbound_group_session_length"><a href="#val-pickle_inbound_group_session_length" class="anchor"></a><code><span class="keyword">val</span> pickle_inbound_group_session_length : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pickle_inbound_group_session_length sess</code></p><p>Returns the number of bytes needed to store an inbound group session</p></dd></dl><dl><dt class="spec value" id="val-pickle_inbound_group_session"><a href="#val-pickle_inbound_group_session" class="anchor"></a><code><span class="keyword">val</span> pickle_inbound_group_session : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pickle_inbound_group_session sess key key_len pickled pickled_len</code></p><p>Initialise an inbound group session object using the supplied memory The supplied memory should be at least olm_inbound_group_session_size() bytes.</p></dd></dl><dl><dt class="spec value" id="val-unpickle_inbound_group_session"><a href="#val-unpickle_inbound_group_session" class="anchor"></a><code><span class="keyword">val</span> unpickle_inbound_group_session : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>unpickle_inbound_group_session sess key key_len pickled pickled_len</code></p><p>Loads a group session from a pickled base64 string. Decrypts the session using the supplied key.</p><p>Returns olm_error() on failure. If the key doesn't match the one used to encrypt the account then olm_inbound_group_session_last_error() will be &quot;BAD_ACCOUNT_KEY&quot;. If the base64 couldn't be decoded then olm_inbound_group_session_last_error() will be &quot;INVALID_BASE64&quot;. The input pickled buffer is destroyed</p></dd></dl><dl><dt class="spec value" id="val-init_inbound_group_session"><a href="#val-init_inbound_group_session" class="anchor"></a><code><span class="keyword">val</span> init_inbound_group_session : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>init_inbound_group_session sess sess_key sess_key_len</code></p><p>Returns the number of bytes needed to store an inbound group session</p></dd></dl><dl><dt class="spec value" id="val-import_inbound_group_session"><a href="#val-import_inbound_group_session" class="anchor"></a><code><span class="keyword">val</span> import_inbound_group_session : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>import_inbound_group_session sess sess_key sess_key_len</code></p><p>Import an inbound group session, from a previous export.</p><p>Returns olm_error() on failure. On failure last_error will be set with an error code. The last_error will be:</p><p>* OLM_INVALID_BASE64 if the session_key is not valid base64 * OLM_BAD_SESSION_KEY if the session_key is invalid</p></dd></dl><dl><dt class="spec value" id="val-group_decrypt_max_plaintext_length"><a href="#val-group_decrypt_max_plaintext_length" class="anchor"></a><code><span class="keyword">val</span> group_decrypt_max_plaintext_length : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>group_decrypt_max_plaintext_length sess msg msg_len</code></p><p>Get an upper bound on the number of bytes of plain-text the decrypt method will write for a given input message length. The actual size could be different due to padding.</p><p>The input message buffer is destroyed.</p><p>Returns olm_error() on failure.</p></dd></dl><dl><dt class="spec value" id="val-group_decrypt"><a href="#val-group_decrypt" class="anchor"></a><code><span class="keyword">val</span> group_decrypt : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>Unsigned.uint32 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>group_decrypt sess msg msg_len plaintext max_plaintext_len msg_index</code></p><p>Decrypt a message. The input message buffer is destroyed. Returns the length of the decrypted plain-text, or olm_error() on failure.</p><p>On failure last_error will be set with an error code. The last_error will be: * OLM_OUTPUT_BUFFER_TOO_SMALL if the plain-text buffer is too small * OLM_INVALID_BASE64 if the message is not valid base-64 * OLM_BAD_MESSAGE_VERSION if the message was encrypted with an unsupported version of the protocol * OLM_BAD_MESSAGE_FORMAT if the message headers could not be decoded * OLM_BAD_MESSAGE_MAC if the message could not be verified * OLM_UNKNOWN_MESSAGE_INDEX if we do not have a session key corresponding to the message's index (ie, it was sent before the session key was shared with us)</p></dd></dl><dl><dt class="spec value" id="val-inbound_group_session_id_length"><a href="#val-inbound_group_session_id_length" class="anchor"></a><code><span class="keyword">val</span> inbound_group_session_id_length : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>inbound_group_session_id_length sess</code></p><p>Get the number of bytes returned by olm_inbound_group_session_id()</p></dd></dl><dl><dt class="spec value" id="val-inbound_group_session_id"><a href="#val-inbound_group_session_id" class="anchor"></a><code><span class="keyword">val</span> inbound_group_session_id : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>inbound_group_session_id sess id id_len</code></p><p>Get a base64-encoded identifier for this session.</p><p>Returns the length of the session id on success or olm_error() on failure. On failure last_error will be set with an error code. The last_error will be OUTPUT_BUFFER_TOO_SMALL if the id buffer was too small.</p></dd></dl><dl><dt class="spec value" id="val-inbound_group_session_first_known_index"><a href="#val-inbound_group_session_first_known_index" class="anchor"></a><code><span class="keyword">val</span> inbound_group_session_first_known_index : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.uint32</code></dt><dd><p><code>inbound_group_session_first_known_index sess</code></p><p>Get the first message index we know how to decrypt.</p></dd></dl><dl><dt class="spec value" id="val-inbound_group_session_is_verified"><a href="#val-inbound_group_session_is_verified" class="anchor"></a><code><span class="keyword">val</span> inbound_group_session_is_verified : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>inbound_group_session_is_verified sess</code></p><p>Check if the session has been verified as a valid session.</p><p>(A session is verified either because the original session share was signed, or because we have subsequently successfully decrypted a message.)</p><p>This is mainly intended for the unit tests, currently.</p></dd></dl><dl><dt class="spec value" id="val-export_inbound_group_session_length"><a href="#val-export_inbound_group_session_length" class="anchor"></a><code><span class="keyword">val</span> export_inbound_group_session_length : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>export_inbound_group_session_length sess</code></p><p>Get the number of bytes returned by olm_export_inbound_group_session()</p></dd></dl><dl><dt class="spec value" id="val-export_inbound_group_session"><a href="#val-export_inbound_group_session" class="anchor"></a><code><span class="keyword">val</span> export_inbound_group_session : <span><a href="../Types/InboundGroupSession/index.html#type-t">Types.InboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.uint32 <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>export_inbound_group_session sess key key_len msg_index</code></p><p>Export the base64-encoded ratchet key for this session, at the given index, in a format which can be used by olm_import_inbound_group_session</p><p>Returns the length of the ratchet key on success or olm_error() on failure. On failure last_error will be set with an error code. The last_error will be: * OUTPUT_BUFFER_TOO_SMALL if the buffer was too small * OLM_UNKNOWN_MESSAGE_INDEX if we do not have a session key corresponding to the given index (ie, it was sent before the session key was shared with us)</p></dd></dl><dl><dt class="spec value" id="val-outbound_group_session_size"><a href="#val-outbound_group_session_size" class="anchor"></a><code><span class="keyword">val</span> outbound_group_session_size : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>outbound_group_session_size ()</code></p><p>Get the size of an outbound group session, in bytes.</p></dd></dl><dl><dt class="spec value" id="val-outbound_group_session"><a href="#val-outbound_group_session" class="anchor"></a><code><span class="keyword">val</span> outbound_group_session : <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span></code></dt><dd><p><code>outbound_group_session mem</code></p><p>Initialise an outbound group session object using the supplied memory The supplied memory should be at least olm_outbound_group_session_size() bytes.</p></dd></dl><dl><dt class="spec value" id="val-outbound_group_session_last_error"><a href="#val-outbound_group_session_last_error" class="anchor"></a><code><span class="keyword">val</span> outbound_group_session_last_error : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>char Ctypes_static.ptr</span></code></dt><dd><p><code>outbound_group_session_last_error sess</code></p><p>A null terminated string describing the most recent error to happen to a group session</p></dd></dl><dl><dt class="spec value" id="val-clear_outbound_group_session"><a href="#val-clear_outbound_group_session" class="anchor"></a><code><span class="keyword">val</span> clear_outbound_group_session : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>clear_outbound_group_session sess</code></p><p>Initialise an outbound group session object using the supplied memory The supplied memory should be at least olm_outbound_group_session_size() bytes.</p></dd></dl><dl><dt class="spec value" id="val-pickle_outbound_group_session_length"><a href="#val-pickle_outbound_group_session_length" class="anchor"></a><code><span class="keyword">val</span> pickle_outbound_group_session_length : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pickle_outbound_group_session_length sess</code></p><p>Get the size of an outbound group session, in bytes.</p></dd></dl><dl><dt class="spec value" id="val-pickle_outbound_group_session"><a href="#val-pickle_outbound_group_session" class="anchor"></a><code><span class="keyword">val</span> pickle_outbound_group_session : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pickle_outbound_group_session sess key key_len pickled pickled_len</code></p><p>Stores a group session as a base64 string. Encrypts the session using the supplied key. Returns the length of the session on success.</p><p>Returns olm_error() on failure. If the pickle output buffer is smaller than olm_pickle_outbound_group_session_length() then olm_outbound_group_session_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;</p></dd></dl><dl><dt class="spec value" id="val-unpickle_outbound_group_session"><a href="#val-unpickle_outbound_group_session" class="anchor"></a><code><span class="keyword">val</span> unpickle_outbound_group_session : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>unpickle_outbound_group_session sess key key_len pickled pickled_len</code></p><p>Loads a group session from a pickled base64 string. Decrypts the session using the supplied key.</p><p>Returns olm_error() on failure. If the key doesn't match the one used to encrypt the account then olm_outbound_group_session_last_error() will be &quot;BAD_ACCOUNT_KEY&quot;. If the base64 couldn't be decoded then olm_outbound_group_session_last_error() will be &quot;INVALID_BASE64&quot;. The input pickled buffer is destroyed</p></dd></dl><dl><dt class="spec value" id="val-init_outbound_group_session_random_length"><a href="#val-init_outbound_group_session_random_length" class="anchor"></a><code><span class="keyword">val</span> init_outbound_group_session_random_length : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>init_outbound_group_session_random_length sess</code></p><p>The number of random bytes needed to create an outbound group session</p></dd></dl><dl><dt class="spec value" id="val-init_outbound_group_session"><a href="#val-init_outbound_group_session" class="anchor"></a><code><span class="keyword">val</span> init_outbound_group_session : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>init_outbound_group_session sess random random_len</code></p><p>Start a new outbound group session. Returns olm_error() on failure. On failure last_error will be set with an error code. The last_error will be NOT_ENOUGH_RANDOM if the number of random bytes was too small.</p></dd></dl><dl><dt class="spec value" id="val-group_encrypt_message_length"><a href="#val-group_encrypt_message_length" class="anchor"></a><code><span class="keyword">val</span> group_encrypt_message_length : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>group_encrypt_message_length sess plaintext_len</code></p><p>The number of bytes that will be created by encrypting a message</p></dd></dl><dl><dt class="spec value" id="val-group_encrypt"><a href="#val-group_encrypt" class="anchor"></a><code><span class="keyword">val</span> group_encrypt : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>group_encrypt sess plaintext plaintext_len msg msg_len</code></p><p>Encrypt some plain-text. Returns the length of the encrypted message or olm_error() on failure. On failure last_error will be set with an error code. The last_error will be OUTPUT_BUFFER_TOO_SMALL if the output buffer is too small.</p></dd></dl><dl><dt class="spec value" id="val-outbound_group_session_id_length"><a href="#val-outbound_group_session_id_length" class="anchor"></a><code><span class="keyword">val</span> outbound_group_session_id_length : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>outbound_group_session_id_length sess</code></p><p>Get the number of bytes returned by olm_outbound_group_session_id()</p></dd></dl><dl><dt class="spec value" id="val-outbound_group_session_id"><a href="#val-outbound_group_session_id" class="anchor"></a><code><span class="keyword">val</span> outbound_group_session_id : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>outbound_group_session_id sess id id_len</code></p><p>Get a base64-encoded identifier for this session.</p><p>Returns the length of the session id on success or olm_error() on failure. On failure last_error will be set with an error code. The last_error will be OUTPUT_BUFFER_TOO_SMALL if the id buffer was too small.</p></dd></dl><dl><dt class="spec value" id="val-outbound_group_session_message_index"><a href="#val-outbound_group_session_message_index" class="anchor"></a><code><span class="keyword">val</span> outbound_group_session_message_index : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.uint32</code></dt><dd><p><code>outbound_group_session_message_index sess</code></p><p>Get the current message index for this session.</p><p>Each message is sent with an increasing index; this returns the index for the next message.</p></dd></dl><dl><dt class="spec value" id="val-outbound_group_session_key_length"><a href="#val-outbound_group_session_key_length" class="anchor"></a><code><span class="keyword">val</span> outbound_group_session_key_length : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>outbound_group_session_key_length sess</code></p><p>Get the number of bytes returned by olm_outbound_group_session_key()</p></dd></dl><dl><dt class="spec value" id="val-outbound_group_session_key"><a href="#val-outbound_group_session_key" class="anchor"></a><code><span class="keyword">val</span> outbound_group_session_key : <span><a href="../Types/OutboundGroupSession/index.html#type-t">Types.OutboundGroupSession.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>outbound_group_session_key sess key key_len</code></p><p>Get the base64-encoded current ratchet key for this session.</p><p>Each message is sent with a different ratchet key. This function returns the ratchet key that will be used for the next message.</p><p>Returns the length of the ratchet key on success or olm_error() on failure. On failure last_error will be set with an error code. The last_error will be OUTPUT_BUFFER_TOO_SMALL if the buffer was too small.</p></dd></dl><dl><dt class="spec value" id="val-get_library_version"><a href="#val-get_library_version" class="anchor"></a><code><span class="keyword">val</span> get_library_version : <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>Unsigned.uint8 Ctypes_static.ptr</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>get_library_version major minor patch</code></p><p>Get the version number of the library. Arguments will be updated if non-null.</p></dd></dl><dl><dt class="spec value" id="val-account_size"><a href="#val-account_size" class="anchor"></a><code><span class="keyword">val</span> account_size : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_size ()</code></p><p>The size of an account object in bytes</p></dd></dl><dl><dt class="spec value" id="val-session_size"><a href="#val-session_size" class="anchor"></a><code><span class="keyword">val</span> session_size : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>session_size ()</code></p><p>The size of a session object in bytes</p></dd></dl><dl><dt class="spec value" id="val-utility_size"><a href="#val-utility_size" class="anchor"></a><code><span class="keyword">val</span> utility_size : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>utility_size ()</code></p><p>The size of a utility object in bytes</p></dd></dl><dl><dt class="spec value" id="val-account"><a href="#val-account" class="anchor"></a><code><span class="keyword">val</span> account : <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span></code></dt><dd><p><code>account mem</code></p><p>Initialise an account object using the supplied memory The supplied memory must be at least olm_account_size() bytes</p></dd></dl><dl><dt class="spec value" id="val-session"><a href="#val-session" class="anchor"></a><code><span class="keyword">val</span> session : <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span></code></dt><dd><p><code>session mem</code></p><p>Initialise a session object using the supplied memory The supplied memory must be at least olm_session_size() bytes</p></dd></dl><dl><dt class="spec value" id="val-utility"><a href="#val-utility" class="anchor"></a><code><span class="keyword">val</span> utility : <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/Utility/index.html#type-t">Types.Utility.t</a> Ctypes_static.ptr</span></code></dt><dd><p><code>utility mem</code></p><p>Initialise a utility object using the supplied memory The supplied memory must be at least olm_utility_size() bytes</p></dd></dl><dl><dt class="spec value" id="val-error"><a href="#val-error" class="anchor"></a><code><span class="keyword">val</span> error : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>error ()</code></p><p>The value that olm will return from a function if there was an error</p></dd></dl><dl><dt class="spec value" id="val-account_last_error"><a href="#val-account_last_error" class="anchor"></a><code><span class="keyword">val</span> account_last_error : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>char Ctypes_static.ptr</span></code></dt><dd><p><code>account_last_error acc</code></p><p>A null terminated string describing the most recent error to happen to an account</p></dd></dl><dl><dt class="spec value" id="val-session_last_error"><a href="#val-session_last_error" class="anchor"></a><code><span class="keyword">val</span> session_last_error : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>char Ctypes_static.ptr</span></code></dt><dd><p><code>session_last_error sess</code></p><p>A null terminated string describing the most recent error to happen to a session</p></dd></dl><dl><dt class="spec value" id="val-utility_last_error"><a href="#val-utility_last_error" class="anchor"></a><code><span class="keyword">val</span> utility_last_error : <span><a href="../Types/Utility/index.html#type-t">Types.Utility.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>char Ctypes_static.ptr</span></code></dt><dd><p><code>utility_last_error util</code></p><p>A null terminated string describing the most recent error to happen to a utility</p></dd></dl><dl><dt class="spec value" id="val-clear_account"><a href="#val-clear_account" class="anchor"></a><code><span class="keyword">val</span> clear_account : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>clear_account acc</code></p><p>Clears the memory used to back this account</p></dd></dl><dl><dt class="spec value" id="val-clear_session"><a href="#val-clear_session" class="anchor"></a><code><span class="keyword">val</span> clear_session : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>clear_session sess</code></p><p>Clears the memory used to back this session</p></dd></dl><dl><dt class="spec value" id="val-clear_utility"><a href="#val-clear_utility" class="anchor"></a><code><span class="keyword">val</span> clear_utility : <span><a href="../Types/Utility/index.html#type-t">Types.Utility.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>clear_utility util</code></p><p>Clears the memory used to back this utility</p></dd></dl><dl><dt class="spec value" id="val-pickle_account_length"><a href="#val-pickle_account_length" class="anchor"></a><code><span class="keyword">val</span> pickle_account_length : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pickle_account_length acc</code></p><p>Returns the number of bytes needed to store an account</p></dd></dl><dl><dt class="spec value" id="val-pickle_session_length"><a href="#val-pickle_session_length" class="anchor"></a><code><span class="keyword">val</span> pickle_session_length : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pickle_session_length sess</code></p><p>Returns the number of bytes needed to store a session</p></dd></dl><dl><dt class="spec value" id="val-pickle_account"><a href="#val-pickle_account" class="anchor"></a><code><span class="keyword">val</span> pickle_account : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pickle_account acc key key_len pickled pickled_len</code></p><p>Stores an account as a base64 string. Encrypts the account using the supplied key. Returns the length of the pickled account on success. Returns olm_error() on failure. If the pickle output buffer is smaller than olm_pickle_account_length() then olm_account_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;</p></dd></dl><dl><dt class="spec value" id="val-pickle_session"><a href="#val-pickle_session" class="anchor"></a><code><span class="keyword">val</span> pickle_session : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pickle_session sess key key_len pickled pickled_len</code></p><p>Stores a session as a base64 string. Encrypts the session using the supplied key. Returns the length of the pickled session on success. Returns olm_error() on failure. If the pickle output buffer is smaller than olm_pickle_session_length() then olm_session_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;</p></dd></dl><dl><dt class="spec value" id="val-unpickle_account"><a href="#val-unpickle_account" class="anchor"></a><code><span class="keyword">val</span> unpickle_account : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>unpickle_account acc key key_len pickled pickled_len</code></p><p>Loads an account from a pickled base64 string. Decrypts the account using the supplied key. Returns olm_error() on failure. If the key doesn't match the one used to encrypt the account then olm_account_last_error() will be &quot;BAD_ACCOUNT_KEY&quot;. If the base64 couldn't be decoded then olm_account_last_error() will be &quot;INVALID_BASE64&quot;. The input pickled buffer is destroyed</p></dd></dl><dl><dt class="spec value" id="val-unpickle_session"><a href="#val-unpickle_session" class="anchor"></a><code><span class="keyword">val</span> unpickle_session : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>unpickle_session sess key key_len pickled pickled_len</code></p><p>Loads a session from a pickled base64 string. Decrypts the session using the supplied key. Returns olm_error() on failure. If the key doesn't match the one used to encrypt the account then olm_session_last_error() will be &quot;BAD_ACCOUNT_KEY&quot;. If the base64 couldn't be decoded then olm_session_last_error() will be &quot;INVALID_BASE64&quot;. The input pickled buffer is destroyed</p></dd></dl><dl><dt class="spec value" id="val-create_account_random_length"><a href="#val-create_account_random_length" class="anchor"></a><code><span class="keyword">val</span> create_account_random_length : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>create_account_random_length acc</code></p><p>The number of random bytes needed to create an account.</p></dd></dl><dl><dt class="spec value" id="val-create_account"><a href="#val-create_account" class="anchor"></a><code><span class="keyword">val</span> create_account : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>create_account acc random random_len</code></p><p>Creates a new account. Returns olm_error() on failure. If there weren't enough random bytes then olm_account_last_error() will be &quot;NOT_ENOUGH_RANDOM&quot;</p></dd></dl><dl><dt class="spec value" id="val-account_identity_keys_length"><a href="#val-account_identity_keys_length" class="anchor"></a><code><span class="keyword">val</span> account_identity_keys_length : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_identity_keys_length acc</code></p><p>The size of the output buffer needed to hold the identity keys</p></dd></dl><dl><dt class="spec value" id="val-account_identity_keys"><a href="#val-account_identity_keys" class="anchor"></a><code><span class="keyword">val</span> account_identity_keys : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_identity_keys acc identity_keys identity_keys_len</code></p><p>Writes the public parts of the identity keys for the account into the identity_keys output buffer. Returns olm_error() on failure. If the identity_keys buffer was too small then olm_account_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;</p></dd></dl><dl><dt class="spec value" id="val-account_signature_length"><a href="#val-account_signature_length" class="anchor"></a><code><span class="keyword">val</span> account_signature_length : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_signature_length acc</code></p><p>The length of an ed25519 signature encoded as base64.</p></dd></dl><dl><dt class="spec value" id="val-account_sign"><a href="#val-account_sign" class="anchor"></a><code><span class="keyword">val</span> account_sign : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_sign acc msg msg_len signature signature_len</code></p><p>Signs a message with the ed25519 key for this account. Returns olm_error() on failure. If the signature buffer was too small then olm_account_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;</p></dd></dl><dl><dt class="spec value" id="val-account_one_time_keys_length"><a href="#val-account_one_time_keys_length" class="anchor"></a><code><span class="keyword">val</span> account_one_time_keys_length : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_one_time_keys_length acc</code> The size of the output buffer needed to hold the one time keys</p></dd></dl><dl><dt class="spec value" id="val-account_one_time_keys"><a href="#val-account_one_time_keys" class="anchor"></a><code><span class="keyword">val</span> account_one_time_keys : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_one_time_keys acc one_time_keys one_time_keys_len</code></p><p>Writes the public parts of the unpublished one time keys for the account into the one_time_keys output buffer.</p><p>The returned data is a JSON-formatted object with the single property curve25519, which is itself an object mapping key id to base64-encoded Curve25519 key. For example:</p><pre><code class="ml">curve25519: {
  &quot;AAAAAA&quot;: &quot;wo76WcYtb0Vk/pBOdmduiGJ0wIEjW4IBMbbQn7aSnTo&quot;;
  &quot;AAAAAB&quot;: &quot;LRvjo46L1X2vx69sS9QNFD29HWulxrmW11Up5AfAjgU&quot;
}</code></pre><p>Returns olm_error() on failure.</p><p>If the one_time_keys buffer was too small then olm_account_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;.</p></dd></dl><dl><dt class="spec value" id="val-account_mark_keys_as_published"><a href="#val-account_mark_keys_as_published" class="anchor"></a><code><span class="keyword">val</span> account_mark_keys_as_published : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_mark_keys_as_published acc</code></p><p>Marks the current set of one time keys as being published.</p></dd></dl><dl><dt class="spec value" id="val-account_max_number_of_one_time_keys"><a href="#val-account_max_number_of_one_time_keys" class="anchor"></a><code><span class="keyword">val</span> account_max_number_of_one_time_keys : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_max_number_of_one_time_keys acc</code> The largest number of one time keys this account can store.</p></dd></dl><dl><dt class="spec value" id="val-account_generate_one_time_keys_random_length"><a href="#val-account_generate_one_time_keys_random_length" class="anchor"></a><code><span class="keyword">val</span> account_generate_one_time_keys_random_length : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_generate_one_time_keys_random_length acc number_of_keys</code> The number of random bytes needed to generate a given number of new one time keys.</p></dd></dl><dl><dt class="spec value" id="val-account_generate_one_time_keys"><a href="#val-account_generate_one_time_keys" class="anchor"></a><code><span class="keyword">val</span> account_generate_one_time_keys : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_generate_one_time_keys acc number_of_keys random random_len</code></p><p>Generates a number of new one time keys. If the total number of keys stored by this account exceeds max_number_of_one_time_keys() then the old keys are discarded. Returns olm_error() on error. If the number of random bytes is too small then olm_account_last_error() will be &quot;NOT_ENOUGH_RANDOM&quot;.</p></dd></dl><dl><dt class="spec value" id="val-account_generate_fallback_key_random_length"><a href="#val-account_generate_fallback_key_random_length" class="anchor"></a><code><span class="keyword">val</span> account_generate_fallback_key_random_length : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_generate_fallback_key_random_length acc</code></p><p>The number of random bytes needed to generate a fallback key.</p></dd></dl><dl><dt class="spec value" id="val-account_generate_fallback_key"><a href="#val-account_generate_fallback_key" class="anchor"></a><code><span class="keyword">val</span> account_generate_fallback_key : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_generate_fallback_key acc random random_len</code></p><p>Generates a new fallback key. Only one previous fallback key is stored. Returns olm_error() on error. If the number of random bytes is too small then olm_account_last_error() will be &quot;NOT_ENOUGH_RANDOM&quot;.</p></dd></dl><dl><dt class="spec value" id="val-account_fallback_key_length"><a href="#val-account_fallback_key_length" class="anchor"></a><code><span class="keyword">val</span> account_fallback_key_length : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_fallback_key_length acc</code></p><p>The number of bytes needed to hold the fallback key as returned by olm_account_fallback_key.</p></dd></dl><dl><dt class="spec value" id="val-account_fallback_key"><a href="#val-account_fallback_key" class="anchor"></a><code><span class="keyword">val</span> account_fallback_key : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>account_fallback_key acc fallback_key fallback_key_size</code></p></dd></dl><dl><dt class="spec value" id="val-create_outbound_session_random_length"><a href="#val-create_outbound_session_random_length" class="anchor"></a><code><span class="keyword">val</span> create_outbound_session_random_length : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>create_outbound_session_random_length sess</code></p><p>The number of random bytes needed to create an outbound session</p></dd></dl><dl><dt class="spec value" id="val-create_outbound_session"><a href="#val-create_outbound_session" class="anchor"></a><code><span class="keyword">val</span> create_outbound_session : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>create_outbound_session
        sess
        acc
        their_identity_key their_identity_key_len
        their_one_time_key their_one_time_key_len
        random             random_len
      </code></p><p>Creates a new out-bound session for sending messages to a given identity_key and one_time_key. Returns olm_error() on failure. If the keys couldn't be decoded as base64 then olm_session_last_error() will be &quot;INVALID_BASE64&quot; If there weren't enough random bytes then olm_session_last_error() will be &quot;NOT_ENOUGH_RANDOM&quot;.</p></dd></dl><dl><dt class="spec value" id="val-create_inbound_session"><a href="#val-create_inbound_session" class="anchor"></a><code><span class="keyword">val</span> create_inbound_session : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>create_inbound_session sess acc one_time_key_msg one_time_key_msg_len</code></p><p>Create a new in-bound session for sending/receiving messages from an incoming PRE_KEY message. Returns olm_error() on failure. If the base64 couldn't be decoded then olm_session_last_error will be &quot;INVALID_BASE64&quot;. If the message was for an unsupported protocol version then olm_session_last_error() will be &quot;BAD_MESSAGE_VERSION&quot;. If the message couldn't be decoded then then olm_session_last_error() will be &quot;BAD_MESSAGE_FORMAT&quot;. If the message refers to an unknown one time key then olm_session_last_error() will be &quot;BAD_MESSAGE_KEY_ID&quot;.</p></dd></dl><dl><dt class="spec value" id="val-create_inbound_session_from"><a href="#val-create_inbound_session_from" class="anchor"></a><code><span class="keyword">val</span> create_inbound_session_from : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>create_inbound_session_from
        sess
        acc
        their_identity_key their_identity_key_len
        one_time_key_msg   one_time_key_msg_len
      </code></p><p>Create a new in-bound session for sending/receiving messages from an incoming PRE_KEY message. Returns olm_error() on failure. If the base64 couldn't be decoded then olm_session_last_error will be &quot;INVALID_BASE64&quot;. If the message was for an unsupported protocol version then olm_session_last_error() will be &quot;BAD_MESSAGE_VERSION&quot;. If the message couldn't be decoded then then olm_session_last_error() will be &quot;BAD_MESSAGE_FORMAT&quot;. If the message refers to an unknown one time key then olm_session_last_error() will be &quot;BAD_MESSAGE_KEY_ID&quot;.</p></dd></dl><dl><dt class="spec value" id="val-session_id_length"><a href="#val-session_id_length" class="anchor"></a><code><span class="keyword">val</span> session_id_length : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>session_id_length sess</code></p><p>The length of the buffer needed to return the id for this session.</p></dd></dl><dl><dt class="spec value" id="val-session_id"><a href="#val-session_id" class="anchor"></a><code><span class="keyword">val</span> session_id : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>session_id sess id id_len</code></p><p>An identifier for this session. Will be the same for both ends of the conversation. If the id buffer is too small then olm_session_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;.</p></dd></dl><dl><dt class="spec value" id="val-session_has_received_message"><a href="#val-session_has_received_message" class="anchor"></a><code><span class="keyword">val</span> session_has_received_message : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>session_has_received_message sess</code></p></dd></dl><dl><dt class="spec value" id="val-session_describe"><a href="#val-session_describe" class="anchor"></a><code><span class="keyword">val</span> session_describe : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>char Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> unit</code></dt><dd><p><code>session_describe sess buf buf_len</code></p><p>Write a null-terminated string describing the internal state of an olm session to the buffer provided for debugging and logging purposes.</p></dd></dl><dl><dt class="spec value" id="val-matches_inbound_session"><a href="#val-matches_inbound_session" class="anchor"></a><code><span class="keyword">val</span> matches_inbound_session : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>matches_inbound_session sess one_time_key_msg one_time_key_msg_len</code></p><p>Checks if the PRE_KEY message is for this in-bound session. This can happen if multiple messages are sent to this account before this account sends a message in reply. The one_time_key_message buffer is destroyed. Returns 1 if the session matches. Returns 0 if the session does not match. Returns olm_error() on failure. If the base64 couldn't be decoded then olm_session_last_error will be &quot;INVALID_BASE64&quot;. If the message was for an unsupported protocol version then olm_session_last_error() will be &quot;BAD_MESSAGE_VERSION&quot;. If the message couldn't be decoded then then olm_session_last_error() will be &quot;BAD_MESSAGE_FORMAT&quot;.</p></dd></dl><dl><dt class="spec value" id="val-matches_inbound_session_from"><a href="#val-matches_inbound_session_from" class="anchor"></a><code><span class="keyword">val</span> matches_inbound_session_from : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>matches_inbound_session_from
        sess
        their_identity_key their_identity_key_len
        one_time_key_msg one_time_key_msg_len
      </code></p><p>Checks if the PRE_KEY message is for this in-bound session. This can happen if multiple messages are sent to this account before this account sends a message in reply. The one_time_key_message buffer is destroyed. Returns 1 if the session matches. Returns 0 if the session does not match. Returns olm_error() on failure. If the base64 couldn't be decoded then olm_session_last_error will be &quot;INVALID_BASE64&quot;. If the message was for an unsupported protocol version then olm_session_last_error() will be &quot;BAD_MESSAGE_VERSION&quot;. If the message couldn't be decoded then then olm_session_last_error() will be &quot;BAD_MESSAGE_FORMAT&quot;.</p></dd></dl><dl><dt class="spec value" id="val-remove_one_time_keys"><a href="#val-remove_one_time_keys" class="anchor"></a><code><span class="keyword">val</span> remove_one_time_keys : <span><a href="../Types/Account/index.html#type-t">Types.Account.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>remove_one_time_keys acc sess</code></p><p>Removes the one time keys that the session used from the account. Returns olm_error() on failure. If the account doesn't have any matching one time keys then olm_account_last_error() will be &quot;BAD_MESSAGE_KEY_ID&quot;.</p></dd></dl><dl><dt class="spec value" id="val-encrypt_message_type"><a href="#val-encrypt_message_type" class="anchor"></a><code><span class="keyword">val</span> encrypt_message_type : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>encrypt_message_type sess</code></p><p>The type of the next message that olm_encrypt() will return. Returns OLM_MESSAGE_TYPE_PRE_KEY if the message will be a PRE_KEY message. Returns OLM_MESSAGE_TYPE_MESSAGE if the message will be a normal message. Returns olm_error on failure.</p></dd></dl><dl><dt class="spec value" id="val-encrypt_random_length"><a href="#val-encrypt_random_length" class="anchor"></a><code><span class="keyword">val</span> encrypt_random_length : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>encrypt_random_length sess</code></p><p>The number of random bytes needed to encrypt the next message.</p></dd></dl><dl><dt class="spec value" id="val-encrypt_message_length"><a href="#val-encrypt_message_length" class="anchor"></a><code><span class="keyword">val</span> encrypt_message_length : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>encrypt_message_length sess plaintext_len</code></p><p>The size of the next message in bytes for the given number of plain-text bytes</p></dd></dl><dl><dt class="spec value" id="val-encrypt"><a href="#val-encrypt" class="anchor"></a><code><span class="keyword">val</span> encrypt : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>encrypt sess plaintext plaintext_len random random_len msg msg_len</code></p><p>Encrypts a message using the session. Returns the length of the message in bytes on success. Writes the message as base64 into the message buffer. Returns olm_error() on failure. If the message buffer is too small then olm_session_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;. If there weren't enough random bytes then olm_session_last_error() will be &quot;NOT_ENOUGH_RANDOM&quot;.</p></dd></dl><dl><dt class="spec value" id="val-decrypt_max_plaintext_length"><a href="#val-decrypt_max_plaintext_length" class="anchor"></a><code><span class="keyword">val</span> decrypt_max_plaintext_length : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>decrypt_max_plaintext_length sess msg_type msg msg_len</code></p><p>The maximum number of bytes of plain-text a given message could decode to. The actual size could be different due to padding. The input message buffer is destroyed. Returns olm_error() on failure. If the message base64 couldn't be decoded then olm_session_last_error() will be &quot;INVALID_BASE64&quot;. If the message is for an unsupported version of the protocol then olm_session_last_error() will be &quot;BAD_MESSAGE_VERSION&quot;. If the message couldn't be decoded then olm_session_last_error() will be &quot;BAD_MESSAGE_FORMAT&quot;.</p></dd></dl><dl><dt class="spec value" id="val-decrypt"><a href="#val-decrypt" class="anchor"></a><code><span class="keyword">val</span> decrypt : <span><a href="../Types/Session/index.html#type-t">Types.Session.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>decrypt sess msg_type msg msg_len plaintext max_plaintext_len</code></p><p>Decrypts a message using the session. The input message buffer is destroyed. Returns the length of the plain-text on success. Returns olm_error() on failure. If the plain-text buffer is smaller than olm_decrypt_max_plaintext_length() then olm_session_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;. If the base64 couldn't be decoded then olm_session_last_error() will be &quot;INVALID_BASE64&quot;. If the message is for an unsupported version of the protocol then olm_session_last_error() will be &quot;BAD_MESSAGE_VERSION&quot;. If the message couldn't be decoded then olm_session_last_error() will be &quot;BAD_MESSAGE_FORMAT&quot;. If the MAC on the message was invalid then olm_session_last_error() will be &quot;BAD_MESSAGE_MAC&quot;.</p></dd></dl><dl><dt class="spec value" id="val-sha256_length"><a href="#val-sha256_length" class="anchor"></a><code><span class="keyword">val</span> sha256_length : <span><a href="../Types/Utility/index.html#type-t">Types.Utility.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>sha256_length util</code></p><p>The length of the buffer needed to hold the SHA-256 hash.</p></dd></dl><dl><dt class="spec value" id="val-sha256"><a href="#val-sha256" class="anchor"></a><code><span class="keyword">val</span> sha256 : <span><a href="../Types/Utility/index.html#type-t">Types.Utility.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>sha256 util input input_len output output_len</code></p><p>Calculates the SHA-256 hash of the input and encodes it as base64. If the output buffer is smaller than olm_sha256_length() then olm_utility_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;.</p></dd></dl><dl><dt class="spec value" id="val-ed25519_verify"><a href="#val-ed25519_verify" class="anchor"></a><code><span class="keyword">val</span> ed25519_verify : <span><a href="../Types/Utility/index.html#type-t">Types.Utility.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>ed25519_verify util key key_len msg msg_len signature signature_len</code></p><p>Verify an ed25519 signature. If the key was too small then olm_utility_last_error() will be &quot;INVALID_BASE64&quot;. If the signature was invalid then olm_utility_last_error() will be &quot;BAD_MESSAGE_MAC&quot;.</p></dd></dl><dl><dt class="spec value" id="val-pk_encryption_size"><a href="#val-pk_encryption_size" class="anchor"></a><code><span class="keyword">val</span> pk_encryption_size : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_encryption_size ()</code></p><p>The size of an encryption object in bytes</p></dd></dl><dl><dt class="spec value" id="val-pk_encryption"><a href="#val-pk_encryption" class="anchor"></a><code><span class="keyword">val</span> pk_encryption : <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/PkEncryption/index.html#type-t">Types.PkEncryption.t</a> Ctypes_static.ptr</span></code></dt><dd><p><code>pk_encryption mem</code></p><p>Initialise an encryption object using the supplied memory The supplied memory must be at least olm_pk_encryption_size() bytes</p></dd></dl><dl><dt class="spec value" id="val-pk_encryption_last_error"><a href="#val-pk_encryption_last_error" class="anchor"></a><code><span class="keyword">val</span> pk_encryption_last_error : <span><a href="../Types/PkEncryption/index.html#type-t">Types.PkEncryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>char Ctypes_static.ptr</span></code></dt><dd><p><code>pk_encryption_last_error encryption</code></p><p>A null terminated string describing the most recent error to happen to an encryption object</p></dd></dl><dl><dt class="spec value" id="val-clear_pk_encryption"><a href="#val-clear_pk_encryption" class="anchor"></a><code><span class="keyword">val</span> clear_pk_encryption : <span><a href="../Types/PkEncryption/index.html#type-t">Types.PkEncryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>clear_pk_encryption encryption</code></p><p>Clears the memory used to back this encryption object</p></dd></dl><dl><dt class="spec value" id="val-pk_encryption_set_recipient_key"><a href="#val-pk_encryption_set_recipient_key" class="anchor"></a><code><span class="keyword">val</span> pk_encryption_set_recipient_key : <span><a href="../Types/PkEncryption/index.html#type-t">Types.PkEncryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_encryption_set_recipient_key encryption public_key public_key_len</code></p><p>Set the recipient's public key for encrypting to</p></dd></dl><dl><dt class="spec value" id="val-pk_ciphertext_length"><a href="#val-pk_ciphertext_length" class="anchor"></a><code><span class="keyword">val</span> pk_ciphertext_length : <span><a href="../Types/PkEncryption/index.html#type-t">Types.PkEncryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_ciphertext_length encryption plaintext_len</code></p><p>Get the length of the ciphertext that will correspond to a plaintext of the given length.</p></dd></dl><dl><dt class="spec value" id="val-pk_mac_length"><a href="#val-pk_mac_length" class="anchor"></a><code><span class="keyword">val</span> pk_mac_length : <span><a href="../Types/PkEncryption/index.html#type-t">Types.PkEncryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_mac_length encryption</code></p><p>Get the length of the message authentication code.</p></dd></dl><dl><dt class="spec value" id="val-pk_key_length"><a href="#val-pk_key_length" class="anchor"></a><code><span class="keyword">val</span> pk_key_length : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_key_length ()</code></p><p>Get the length of a public or ephemeral key</p></dd></dl><dl><dt class="spec value" id="val-pk_encrypt_random_length"><a href="#val-pk_encrypt_random_length" class="anchor"></a><code><span class="keyword">val</span> pk_encrypt_random_length : <span><a href="../Types/PkEncryption/index.html#type-t">Types.PkEncryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_encrypt_random_length encryption</code></p><p>The number of random bytes needed to encrypt a message.</p></dd></dl><dl><dt class="spec value" id="val-pk_encrypt"><a href="#val-pk_encrypt" class="anchor"></a><code><span class="keyword">val</span> pk_encrypt : <span><a href="../Types/PkEncryption/index.html#type-t">Types.PkEncryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_encrypt
        encryption
        plaintext    plaintext_len
        ciphertext   ciphertext_len
        mac          mac_len
        ephermal_key ephemeral_key_size
        random       random_len
      </code></p><p>Encrypt a plaintext for the recipient set using olm_pk_encryption_set_recipient_key. Writes to the ciphertext, mac, and ephemeral_key buffers, whose values should be sent to the recipient. mac is a Message Authentication Code to ensure that the data is received and decrypted properly. ephemeral_key is the public part of the ephemeral key used (together with the recipient's key) to generate a symmetric encryption key. Returns olm_error() on failure. If the ciphertext, mac, or ephemeral_key buffers were too small then olm_pk_encryption_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;. If there weren't enough random bytes then olm_pk_encryption_last_error() will be &quot;OLM_INPUT_BUFFER_TOO_SMALL&quot;.</p></dd></dl><dl><dt class="spec value" id="val-pk_decryption_size"><a href="#val-pk_decryption_size" class="anchor"></a><code><span class="keyword">val</span> pk_decryption_size : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_decryption_size ()</code></p><p>The size of a decryption object in bytes</p></dd></dl><dl><dt class="spec value" id="val-pk_decryption"><a href="#val-pk_decryption" class="anchor"></a><code><span class="keyword">val</span> pk_decryption : <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/PkDecryption/index.html#type-t">Types.PkDecryption.t</a> Ctypes_static.ptr</span></code></dt><dd><p><code>pk_decryption mem</code></p><p>Initialise a decryption object using the supplied memory The supplied memory must be at least olm_pk_decryption_size() bytes</p></dd></dl><dl><dt class="spec value" id="val-pk_decryption_last_error"><a href="#val-pk_decryption_last_error" class="anchor"></a><code><span class="keyword">val</span> pk_decryption_last_error : <span><a href="../Types/PkDecryption/index.html#type-t">Types.PkDecryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>char Ctypes_static.ptr</span></code></dt><dd><p><code>pk_decryption_last_error decryption</code></p><p>A null terminated string describing the most recent error to happen to a decription object</p></dd></dl><dl><dt class="spec value" id="val-clear_pk_decryption"><a href="#val-clear_pk_decryption" class="anchor"></a><code><span class="keyword">val</span> clear_pk_decryption : <span><a href="../Types/PkDecryption/index.html#type-t">Types.PkDecryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>clear_pk_decryption decryption</code></p><p>Clears the memory used to back this decryption object</p></dd></dl><dl><dt class="spec value" id="val-pk_private_key_length"><a href="#val-pk_private_key_length" class="anchor"></a><code><span class="keyword">val</span> pk_private_key_length : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_private_key_length ()</code></p><p>Get the number of bytes required to store an olm private key</p></dd></dl><dl><dt class="spec value" id="val-pk_key_from_private"><a href="#val-pk_key_from_private" class="anchor"></a><code><span class="keyword">val</span> pk_key_from_private : <span><a href="../Types/PkDecryption/index.html#type-t">Types.PkDecryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_key_from_private decryption pubkey pubkey_len privkey privkey_len</code></p><p>Initialise the key from the private part of a key as returned by olm_pk_get_private_key(). The associated public key will be written to the pubkey buffer. Returns olm_error() on failure. If the pubkey buffer is too small then olm_pk_decryption_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;. If the private key was not long enough then olm_pk_decryption_last_error() will be &quot;OLM_INPUT_BUFFER_TOO_SMALL&quot;.</p><p>Note that the pubkey is a base64 encoded string, but the private key is an unencoded byte array</p></dd></dl><dl><dt class="spec value" id="val-pickle_pk_decryption_length"><a href="#val-pickle_pk_decryption_length" class="anchor"></a><code><span class="keyword">val</span> pickle_pk_decryption_length : <span><a href="../Types/PkDecryption/index.html#type-t">Types.PkDecryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pickle_pk_decryption_length decryption</code></p><p>Returns the number of bytes needed to store a decryption object.</p></dd></dl><dl><dt class="spec value" id="val-pickle_pk_decryption"><a href="#val-pickle_pk_decryption" class="anchor"></a><code><span class="keyword">val</span> pickle_pk_decryption : <span><a href="../Types/PkDecryption/index.html#type-t">Types.PkDecryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pickle_pk_decryption decryption key key_len pickled pickled_len</code></p><p>Stores decryption object as a base64 string. Encrypts the object using the supplied key. Returns the length of the pickled object on success. Returns olm_error() on failure. If the pickle output buffer is smaller than olm_pickle_pk_decryption_length() then olm_pk_decryption_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;</p></dd></dl><dl><dt class="spec value" id="val-unpickle_pk_decryption"><a href="#val-unpickle_pk_decryption" class="anchor"></a><code><span class="keyword">val</span> unpickle_pk_decryption : <span><a href="../Types/PkDecryption/index.html#type-t">Types.PkDecryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>unpickle_pk_decryption decryption key key_len pickled pickled_len</code></p><p>Loads a decryption object from a pickled base64 string. The associated public key will be written to the pubkey buffer. Decrypts the object using the supplied key. Returns olm_error() on failure. If the key doesn't match the one used to encrypt the account then olm_pk_decryption_last_error() will be &quot;BAD_ACCOUNT_KEY&quot;. If the base64 couldn't be decoded then olm_pk_decryption_last_error() will be &quot;INVALID_BASE64&quot;. The input pickled buffer is destroyed</p></dd></dl><dl><dt class="spec value" id="val-pk_max_plaintext_length"><a href="#val-pk_max_plaintext_length" class="anchor"></a><code><span class="keyword">val</span> pk_max_plaintext_length : <span><a href="../Types/PkDecryption/index.html#type-t">Types.PkDecryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_max_plaintext_length decryption ciphertext_len</code></p><p>Get the length of the plaintext that will correspond to a ciphertext of the given length.</p></dd></dl><dl><dt class="spec value" id="val-pk_decrypt"><a href="#val-pk_decrypt" class="anchor"></a><code><span class="keyword">val</span> pk_decrypt : <span><a href="../Types/PkDecryption/index.html#type-t">Types.PkDecryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_decrypt
        decryption
        ephemeral_key ephemeral_key_len
        mac           mac_len
        ciphertext    ciphertext_len
        plaintext     max_plaintext_len
      </code></p><p>Decrypt a ciphertext. The input ciphertext buffer is destroyed. See the olm_pk_encrypt function for descriptions of the ephemeral_key and mac arguments. Returns the length of the plaintext on success. Returns olm_error() on failure. If the plaintext buffer is too small then olm_pk_encryption_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;.</p></dd></dl><dl><dt class="spec value" id="val-pk_get_private_key"><a href="#val-pk_get_private_key" class="anchor"></a><code><span class="keyword">val</span> pk_get_private_key : <span><a href="../Types/PkDecryption/index.html#type-t">Types.PkDecryption.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_get_private_key decryption private_key private_key_len</code></p><p>Get the private key for an OlmDecryption object as an unencoded byte array private_key must be a pointer to a buffer of at least olm_pk_private_key_length() bytes and this length must be passed in private_key_length. If the given buffer is too small, returns olm_error() and olm_pk_encryption_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;. Returns the number of bytes written.</p></dd></dl><dl><dt class="spec value" id="val-pk_signing_size"><a href="#val-pk_signing_size" class="anchor"></a><code><span class="keyword">val</span> pk_signing_size : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_signing_size ()</code></p><p>The size of a signing object in bytes</p></dd></dl><dl><dt class="spec value" id="val-pk_signing"><a href="#val-pk_signing" class="anchor"></a><code><span class="keyword">val</span> pk_signing : <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/PkSigning/index.html#type-t">Types.PkSigning.t</a> Ctypes_static.ptr</span></code></dt><dd><p><code>pk_signing mem</code></p><p>Initialise a signing object using the supplied memory The supplied memory must be at least olm_pk_signing_size() bytes</p></dd></dl><dl><dt class="spec value" id="val-pk_signing_last_error"><a href="#val-pk_signing_last_error" class="anchor"></a><code><span class="keyword">val</span> pk_signing_last_error : <span><a href="../Types/PkSigning/index.html#type-t">Types.PkSigning.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>char Ctypes_static.ptr</span></code></dt><dd><p><code>pk_signing_last_error sign</code></p><p>A null terminated string describing the most recent error to happen to a signing object</p></dd></dl><dl><dt class="spec value" id="val-clear_pk_signing"><a href="#val-clear_pk_signing" class="anchor"></a><code><span class="keyword">val</span> clear_pk_signing : <span><a href="../Types/PkSigning/index.html#type-t">Types.PkSigning.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>clear_pk_signing sign</code></p><p>Clears the memory used to back this signing object</p></dd></dl><dl><dt class="spec value" id="val-pk_signing_key_from_seed"><a href="#val-pk_signing_key_from_seed" class="anchor"></a><code><span class="keyword">val</span> pk_signing_key_from_seed : <span><a href="../Types/PkSigning/index.html#type-t">Types.PkSigning.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_signing_key_from_seed sign pubkey pubkey_len seed seed_len</code></p><p>Initialise the signing object with a public/private keypair from a seed. The associated public key will be written to the pubkey buffer. Returns olm_error() on failure. If the public key buffer is too small then olm_pk_signing_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;. If the seed buffer is too small then olm_pk_signing_last_error() will be &quot;INPUT_BUFFER_TOO_SMALL&quot;.</p></dd></dl><dl><dt class="spec value" id="val-pk_signing_seed_length"><a href="#val-pk_signing_seed_length" class="anchor"></a><code><span class="keyword">val</span> pk_signing_seed_length : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_signing_seed_length ()</code></p><p>The size required for the seed for initialising a signing object.</p></dd></dl><dl><dt class="spec value" id="val-pk_signing_public_key_length"><a href="#val-pk_signing_public_key_length" class="anchor"></a><code><span class="keyword">val</span> pk_signing_public_key_length : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_signing_public_key_length ()</code></p><p>The size of the public key of a signing object.</p></dd></dl><dl><dt class="spec value" id="val-pk_signature_length"><a href="#val-pk_signature_length" class="anchor"></a><code><span class="keyword">val</span> pk_signature_length : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_signature_length ()</code></p><p>The size of a signature created by a signing object.</p></dd></dl><dl><dt class="spec value" id="val-pk_sign"><a href="#val-pk_sign" class="anchor"></a><code><span class="keyword">val</span> pk_sign : <span><a href="../Types/PkSigning/index.html#type-t">Types.PkSigning.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>pk_sign sign msg msg_len signature signature_len</code></p><p>Sign a message. The signature will be written to the signature buffer. Returns olm_error() on failure. If the signature buffer is too small, olm_pk_signing_last_error() will be &quot;OUTPUT_BUFFER_TOO_SMALL&quot;.</p></dd></dl><dl><dt class="spec value" id="val-sas_last_error"><a href="#val-sas_last_error" class="anchor"></a><code><span class="keyword">val</span> sas_last_error : <span><a href="../Types/SAS/index.html#type-t">Types.SAS.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>char Ctypes_static.ptr</span></code></dt><dd><p><code>sas_last_error sas</code></p><p>A null terminated string describing the most recent error to happen to an SAS object.</p></dd></dl><dl><dt class="spec value" id="val-sas_size"><a href="#val-sas_size" class="anchor"></a><code><span class="keyword">val</span> sas_size : unit <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>sas_size ()</code></p><p>The size of an SAS object in bytes.</p></dd></dl><dl><dt class="spec value" id="val-sas"><a href="#val-sas" class="anchor"></a><code><span class="keyword">val</span> sas : <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span><a href="../Types/SAS/index.html#type-t">Types.SAS.t</a> Ctypes_static.ptr</span></code></dt><dd><p><code>sas mem</code></p><p>Initialize an SAS object using the supplied memory. The supplied memory must be at least `olm_sas_size()` bytes.</p></dd></dl><dl><dt class="spec value" id="val-clear_sas"><a href="#val-clear_sas" class="anchor"></a><code><span class="keyword">val</span> clear_sas : <span><a href="../Types/SAS/index.html#type-t">Types.SAS.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>clear_sas sas</code></p><p>Clears the memory used to back an SAS object.</p></dd></dl><dl><dt class="spec value" id="val-create_sas_random_length"><a href="#val-create_sas_random_length" class="anchor"></a><code><span class="keyword">val</span> create_sas_random_length : <span><a href="../Types/SAS/index.html#type-t">Types.SAS.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>create_sas_random_length sas</code></p><p>The number of random bytes needed to create an SAS object.</p></dd></dl><dl><dt class="spec value" id="val-create_sas"><a href="#val-create_sas" class="anchor"></a><code><span class="keyword">val</span> create_sas : <span><a href="../Types/SAS/index.html#type-t">Types.SAS.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>create_sass sas random random_len</code></p><p>Creates a new SAS object.</p><p>Takes the SAS object to create, initialized by `olm_sas()`, and an array of random bytes (and it's length) to use as entropy. The contents of the random buffer may be overwritten.</p><p>Returns `olm_error()` on failure. If there weren't enough random bytes then `olm_sas_last_error()` will be `NOT_ENOUGH_RANDOM`.</p></dd></dl><dl><dt class="spec value" id="val-sas_pubkey_length"><a href="#val-sas_pubkey_length" class="anchor"></a><code><span class="keyword">val</span> sas_pubkey_length : <span><a href="../Types/SAS/index.html#type-t">Types.SAS.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>sas_pubkey_length sas</code></p><p>The size of a public key in bytes.</p></dd></dl><dl><dt class="spec value" id="val-sas_get_pubkey"><a href="#val-sas_get_pubkey" class="anchor"></a><code><span class="keyword">val</span> sas_get_pubkey : <span><a href="../Types/SAS/index.html#type-t">Types.SAS.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>sas_get_pubkey sas pubkey pubkey_len</code></p><p>Get the public key for the SAS object. Takes a buffer in which to store the public key, which must be of at least `olm_sas_pubkey_length()`.</p><p>Returns `olm_error()` on failure. If the `pubkey` buffer is too small, then `olm_sas_last_error()` will be `OUTPUT_BUFFER_TOO_SMALL`.</p></dd></dl><dl><dt class="spec value" id="val-sas_set_their_key"><a href="#val-sas_set_their_key" class="anchor"></a><code><span class="keyword">val</span> sas_set_their_key : <span><a href="../Types/SAS/index.html#type-t">Types.SAS.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>sas_set_their_key sas their_key their_key_len</code></p><p>Sets the public key of other user. Takes the SAS object, and the other user's public key (which will be overwritten).</p><p>Returns `olm_error()` on failure. If the `their_key` buffer is too small, then `olm_sas_last_error()` will be `INPUT_BUFFER_TOO_SMALL`.</p></dd></dl><dl><dt class="spec value" id="val-sas_is_their_key_set"><a href="#val-sas_is_their_key_set" class="anchor"></a><code><span class="keyword">val</span> sas_is_their_key_set : <span><a href="../Types/SAS/index.html#type-t">Types.SAS.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>sas_is_their_key_set sas</code></p><p>Checks if their key was set.</p></dd></dl><dl><dt class="spec value" id="val-sas_generate_bytes"><a href="#val-sas_generate_bytes" class="anchor"></a><code><span class="keyword">val</span> sas_generate_bytes : <span><a href="../Types/SAS/index.html#type-t">Types.SAS.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>sas_generate_bytes sas info info_len output output_len</code></p><p>Generate bytes to use for the short authentication string.</p><p>Takes a SAS object, extra information to mix in when generating the bytes, as per the Matrix spec, and a buffer in which to store the output. For hex-based SAS as in the Matrix spec, the length of the output will be 5.</p></dd></dl><dl><dt class="spec value" id="val-sas_mac_length"><a href="#val-sas_mac_length" class="anchor"></a><code><span class="keyword">val</span> sas_mac_length : <span><a href="../Types/SAS/index.html#type-t">Types.SAS.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>sas_mac_length sas</code></p><p>The size of the message authentication code generated by olm_sas_calculate_mac()`.</p></dd></dl><dl><dt class="spec value" id="val-sas_calculate_mac"><a href="#val-sas_calculate_mac" class="anchor"></a><code><span class="keyword">val</span> sas_calculate_mac : <span><a href="../Types/SAS/index.html#type-t">Types.SAS.t</a> Ctypes_static.ptr</span> <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> <span>unit Ctypes_static.ptr</span> <span>&#45;&gt;</span> Unsigned.size_t <span>&#45;&gt;</span> Unsigned.size_t</code></dt><dd><p><code>sas_calculate_mac sas input input_len info info_len mac mac_len</code></p><p>Generate a message authentication code (MAC) based on the shared secret.</p><p>Takes a SAS object, the message to produce the authentication code for, the extra information to mix in when generating the MAC, as per the Matrix spec, and the buffer in which to store the generated MAC.</p><p>Returns `olm_error()` on failure. If the `mac` buffer is too small, then `olm_sas_last_error()` will be `OUTPUT_BUFFER_TOO_SMALL`.</p></dd></dl></div></body></html>